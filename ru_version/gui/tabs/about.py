import tkinter as tk
import webbrowser
import sys
from gui.base_tab import BaseTab

# Ссылка на репозиторий
REPO_URL = "https://github.com/GlebK1101/AES-GCM-GUI"

class AboutTab(BaseTab):
    def setup_ui(self):
        # Очистка контейнера
        for widget in self.main_frame.winfo_children():
            widget.destroy()

        # --- ШАПКА ---
        header_frame = tk.Frame(self.main_frame)
        header_frame.pack(fill='x', pady=(0, 10))

        tk.Label(header_frame, text="Argon2id & AES-GCM Encryptor", 
                 font=("Arial", 20, "bold"), fg="#333").pack()
        
        ver_info = f"Версия 1.0.0 | Python {sys.version.split()[0]}"
        tk.Label(header_frame, text=ver_info, font=("Arial", 10), fg="#666").pack()

        # Ссылка
        link = tk.Label(header_frame, text="GitHub репозиторий", 
                        font=("Arial", 10, "underline"), fg="blue", cursor="hand2")
        link.pack(pady=5)
        link.bind("<Button-1>", lambda e: webbrowser.open_new(REPO_URL))

        # --- ТЕКСТОВОЕ ПОЛЕ С ИНСТРУКЦИЕЙ ---
        text_frame = tk.Frame(self.main_frame, bd=1, relief="sunken")
        text_frame.pack(fill="both", expand=True)

        scrollbar = tk.Scrollbar(text_frame)
        scrollbar.pack(side="right", fill="y")

        self.txt = tk.Text(text_frame, font=("Consolas", 12), wrap="word",
                           yscrollcommand=scrollbar.set, padx=10, pady=10, bg="white")
        self.txt.pack(fill="both", expand=True)
        scrollbar.config(command=self.txt.yview)

        # Настраиваем только те стили, которые реально используются
        self.txt.tag_configure("h1", font=("Arial", 14, "bold"), spacing3=10, foreground="#2c3e50", justify='center')
        self.txt.tag_configure("important", foreground="#d35400", font=("Consolas", 10, "bold"))
        self.txt.tag_configure("bold", font=("Consolas", 10, "bold"))

        self.fill_manual()
        self.txt.config(state="disabled") # Только чтение

    def fill_manual(self):
        """Здесь мы пишем текст инструкции"""
        manual = """
=== 1. Немного от автора ===
Эта программа создавалась как инструмент для людей, которым важно полностью контролировать свои данные и не доверять их никому лишнему. В каком-то смысле она действительно рассчитана на «параноиков» — но на параноиков разумных, которые понимают, зачем им такая степень защиты.

В основе лежат современные криптографические алгоритмы промышленного уровня. Для шифрования данных используется AES в режиме GCM, а для защиты пароля — Argon2id. Это не экспериментальные решения и не самодельная криптография, а проверенные стандарты, применяемые в реальных системах безопасности и устойчивые к известным атакам.

Программа не хранит копии ключей и не имеет «мастер-пароля» или аварийного способа восстановления. Это осознанный выбор. Вся ответственность за сохранность пароля и параметров шифрования лежит на пользователе. Если пароль будет забыт или конфигурационный файл с настройками KDF будет утерян, восстановление данных станет математически невозможным. В этом случае не поможет никто, включая разработчика программы.

=== 2. Вкладка: Одиночный файл ===
Шифрование одиночного файла происходит через полную загрузку всего файла в оперативную память программы. Программа шифрует данные и сразу записывает результат. Нюанс в том, что если файл весит слишком много (больше, чем доступно свободной RAM), программа может зависнуть или вылететь с ошибкой. Для больших файлов (фильмы, архивы, образы дисков) используйте вкладку "Поток".

Обязательные поля: 
- Файл
- Пароль (пробелы по краям пароля удаляются!)

Остальные поля опциональны. Если вы их не укажете, программа выберет значения по умолчанию:
1. Папка сохранения = папка исходного файла.
2. Имя выходного файла = случайный набор символов (длина настраивается в "Настройках").
Реализована защита от коллизий: если случайное имя совпадет с уже существующим, программа сгенерирует другое.

Для дешифрования правила те же. Важно: при расшифровке мы не проверяем существование файла с таким именем. Если в папке уже лежит файл с оригинальным именем, он будет молча перезаписан расшифрованной версией. Это сделано намеренно для удобства автоматизации, но будьте внимательны.

=== 3. Вкладка: Поток ===
Здесь меняется метод работы с данными. Шифрование и дешифрование происходят "пакетным" способом (чанками). Размер файла не имеет значения: можно шифровать хоть терабайтный архив, имея всего 2 ГБ оперативной памяти.
Размер одного кусочка (чанка) задается во вкладке "Настройки".

Важно: Формат контейнеров (структура байтов) в режимах "Одиночный файл" и "Поток" отличается. Вы не сможете расшифровать "потоковый" файл во вкладке "Одиночный файл" и наоборот, даже если пароль верный.

=== 4. Вкладка: Манифест ===
Метод шифрования — потоковый (как в пункте 3), но применяется ко всей структуре папок рекурсивно.
Эта вкладка предназначена для защиты целых директорий. Программа берет все файлы, шифрует их, дает им случайные имена и сваливает в одну общую папку ("кучу") без подпапок.

Параллельно создается файл manifest.json. Он НЕ шифруется автоматически (рекомендую зашифровать его отдельно). В этом файле описана карта: какое случайное имя какому реальному файлу соответствует и где он лежал.
Этот файл нужен ТОЛЬКО для автоматического восстановления структуры. Его потеря НЕ означает потерю данных. Если вы потеряли манифест, вы просто получите кучу файлов с именами типа "a8z9.enc". Их можно расшифровать поштучно через вкладку "Поток" — содержимое восстановится корректно.

=== 5. Вкладка: Стеганография ===
Позволяет спрятать данные внутри картинки. Технически данные просто приписываются в конец файла изображения (после специального байта-терминатора). Размер выходной картинки равен сумме исходной картинки и спрятанного файла.

Важное ограничение: В этой вкладке файлы загружаются в оперативную память целиком. Если вы попытаетесь спрятать файл размером 10 ГБ, имея всего 4 ГБ памяти, программа может зависнуть или закрыться. Проверки на нехватку памяти здесь нет — рассчитывайте ресурсы сами.

Внимание: Если отправить такую картинку через мессенджер (Telegram, WhatsApp) без упаковки в архив, сервер сожмет картинку и обрежет "лишний" хвост с вашими данными. Данные будут уничтожены. Передавайте только файлом/архивом.
При извлечении вы получаете и чистую картинку, и спрятанный файл.

=== 6. Вкладка: Шредер ===
При обычном удалении файла ОС Windows просто помечает место на диске как "свободное", но сами байты данных остаются лежать там, пока их чем-то не перезапишут. Специальные программы легко их восстанавливают.
Шредер перезаписывает содержимое файла случайным мусором, затем переименовывает его в случайную абракадабру (чтобы скрыть исходное имя файла, так как оно тоже хранится в файловой системе) и только потом удаляет. Можно удалять как отдельные файлы, так и папки целиком.

=== 7. Вкладка: Настройки ===
Здесь задается математика защиты.
- Длина имени: границы для генерации случайных имен файлов.
- AAD (Additional Authenticated Data): Считайте это "вторым паролем" или контекстной меткой. Если вы зашифровали файл с AAD "Документы2024", то при расшифровке вы ОБЯЗАНЫ указать эту же строку в настройках. Без нее файл не откроется, даже если пароль верный.
- Chunk size: Размер порции данных, считываемой за раз в режимах "Поток" и "Манифест".
- Key length: Длина ключа. 32 байта = 256 бит (максимум для AES).
- Iterations: Количество проходов по памяти при создании ключа из пароля. Заставляет процессор работать дольше. Выше 4 ставить не стоит — будет слишком долго.
- Memory: Объем RAM (в КБ), который выделяется для расчета хеша. Делает атаку "дорогой". Если поставить 65536 (64 МБ), то хакер не сможет запустить миллион подборов пароля на одной видеокарте — у него просто кончится память.
- Lanes: Количество потоков. При lanes=1 атака становится последовательной и GPU теряет преимущество. 

В полях с цифрами можно писать выражения: "64*1024" программа поймет как "65536". Не забудьте нажать "Применить настройки".

=== 8. Вкладка: Утилиты ===
Полезные мелочи для безопасности.
- Генератор паролей: Создает сложные строки, которые реально трудно взломать, но возможно ввести руками.
- Проверка целостности: Считает хеш (цифровой отпечаток) файла. Если хотя бы один бит в файле изменится, хеш станет совершенно другим. Нужно для проверки: "А точно ли файл скачался без ошибок?".
- Мастер-экспорт: Сохраняет текущую конфигурацию, последний сгенерированный пароль и хеш в один JSON файл. Осторожно: пароль там в открытом виде!

=== 9. Про детали ===
! Важный совет
Используйте пароль при шифровании не менее 24 символов. Так надежнее. 

! Path Traversal (Выход за пределы папки)
В файле manifest.json хранятся пути. Злоумышленник может это использовать.
Представьте: у вас есть папка восстановления C:\\Photos.
В манифесте написано: "Восстанови файл cat.jpg".
Программа делает: C:\\Photos + cat.jpg = C:\\Photos\\cat.jpg. Всё хорошо.
Атака: Злоумышленник незаметно меняет манифест. Вместо cat.jpg он пишет: ..\\..\\Windows\\System32\\virus.exe.
Символы ".." означают "выйти в папку выше".
Программа склеивает: C:\\Photos + .. + .. + Windows...
Итог: Вы думали, что восстанавливаете фотки, а программа "выпрыгнула" из папки и записала вирус в систему. В этой программе встроена защита от таких трюков.

! Количество проходов Шредера
Нужно ли стирать файл 3 или 7 раз?
1. Для жестких дисков (HDD): Раньше считалось, что по краям магнитной дорожки может остаться "тень" данных. Поэтому придумали стандарты в 3 прохода (DoD) и 35 проходов (Гутман). Для современных HDD плотность записи такая дикая, что попасть в тот же атом дважды невозможно. Поэтому 1 прохода случайными данными (не нулями!) вполне достаточно.
2. Для SSD и флешек: Тут всё сложнее. У SSD есть контроллер, который следит за износом ячеек. Когда вы говорите "Перезапиши файл в ячейке №100", контроллер может сказать: "Ячейка №100 устала, я запишу новые данные в свежую ячейку №500, а старую просто помечу как пустую".
Итог: физически старые данные остались в ячейке №100. Поэтому даже 7 проходов на SSD не дают 100% гарантии уничтожения. Надежнее всего использовать полное стирание диска (Secure Erase) через BIOS.
Резюме: 1 проход — достаточно от программ восстановления. 3 прохода — для успокоения. 7 проходов — избыточно.

! Технические ограничения формата
Программа записывает служебные данные в бинарном виде, поэтому существуют математические пределы:
1. Имя файла: На хранение длины имени выделено 2 байта. Это значит, что имя файла не может превышать 65535 символов.
2. Расширение: Выделен 1 байт. Максимум 255 символов.
3. Размер чанка (Chunk Size): В режиме потока на длину блока данных выделено 4 байта. Это значит, что один чанк в настройках строго не должен превышать 4 ГБ (4 294 967 295 байт). Если выставить больше — математика переполнится и файл будет поврежден при записи.
4. Для стеганографии ограничения сдвинуты вверх в два раза: 4 байта на имя и 8 байт на данные.

! AES-GCM и "Цифровая пломба"
Почему мы используем именно режим GCM, а не просто AES?
Обычное шифрование (как в старых архиваторах) работает как замок на двери. Если у вас есть ключ (пароль), вы открываете дверь. Но если злоумышленник ночью подпилит петли или просверлит дырку в стене (изменит байты внутри зашифрованного файла), обычный алгоритм этого не заметит. Он просто расшифрует вам "кашу" и битый файл.

AES-GCM — это "Аутентифицированное шифрование".
Представьте, что мы не просто заперли данные в сейф, но и повесили на него химическую пломбу.
В процессе шифрования алгоритм считает сложную контрольную сумму (Tag) от всех ваших данных. Это происходит на уровне математики шифра, а не на уровне нашей программы.

Когда вы вводите пароль для расшифровки, AES-GCM сначала проверяет эту пломбу:
1. Если файл скачался с ошибкой (битый интернет);
2. Если вирус "побил" файл на диске;
3. Если хакер намеренно изменил хоть один бит внутри контейнера;
...то математика просто не сойдется. Алгоритм выдаст ошибку "InvalidTag" и откажется выдавать вам данные.

Это гарантирует абсолютную целостность: вы получите либо файл байт-в-байт как оригинал, либо ошибку. Вы никогда не получите испорченный, "глючный" или поддельный файл.
        """
        
        self.txt.config(state="normal")
        self.txt.delete("1.0", tk.END)
        self.txt.insert("1.0", manual)
        
        # Автоматическое форматирование заголовков и списков
        count_lines = int(self.txt.index('end-1c').split('.')[0])
        for i in range(1, count_lines + 1):
            line_text = self.txt.get(f"{i}.0", f"{i}.end").strip()
            
            if not line_text:
                continue

            if line_text.startswith("==="):
                self.txt.tag_add("h1", f"{i}.0", f"{i}.end")
            elif line_text.startswith("!"):
                self.txt.tag_add("important", f"{i}.0", f"{i}.end")

        self.txt.config(state="disabled")